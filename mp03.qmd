---
title: "Mini-Project 03"
subtitle: "Visualizing and Maintaining the Green Canopy of NYC"
author: "rahicodes"
editor:
    mode: source
format:
    html:
        code-fold: true
---

# Introduction
Trees play a vital role in New York City‚Äôs environmental health, economic vitality, and residents‚Äô overall quality of life. With over 900,000 street trees distributed across the five boroughs, the NYC Parks Department is responsible for their care and maintenance. Ensuring that every neighborhood benefits equally from this urban canopy requires thoughtful planning and investment.

This project examines how street trees are distributed across City Council districts to identify areas that may be underserved. The analysis aims to highlight districts where targeted tree-planting initiatives could promote greater environmental equity and enhance the city‚Äôs overall green infrastructure.

# Data Acquisition
### NYC City Council Districts
```{r}
# Libraries
library(sf)
library(tidyverse)
library(httr2)
library(glue)
library(fs)
library(lubridate)

# Recommended project data directory
dir_mp03 <- "data/mp03"
dir_create(dir_mp03)
```

### Task 1: Download NYC City Council District Boundaries
```{r}
get_nyc_council_districts <- function() {
  # Look for manually downloaded files in multiple possible locations
  base_paths <- c(
    ".",  # Current working directory
    "C:/Users/kdsha/OneDrive/Documents/STA9750-2025-FALL",  # Your actual project location
    file.path(Sys.getenv("USERPROFILE"), "OneDrive", "Documents", "STA9750-2025-FALL")  # Generic path
  )
  
  possible_dirs <- c()
  for (base in base_paths) {
    possible_dirs <- c(possible_dirs,
      file.path(base, "nycc_25c"),           # Land-only version (preferred)
      file.path(base, "nyccwi_25c"),         # Version with water areas
      file.path(base, "data", "mp03", "nycc_25c"),
      file.path(base, "data", "mp03", "nyccwi_25c")
    )
  }
  
  shp_file <- NULL
  found_dir <- NULL
  
  cat("Searching for council district shapefiles...\n")
  for (dir in possible_dirs) {
    if (dir.exists(dir)) {
      cat("Checking directory:", dir, "\n")
      shp_files <- list.files(dir, pattern = "\\.shp$", full.names = TRUE, recursive = TRUE)
      if (length(shp_files) > 0) {
        shp_file <- shp_files[1]
        found_dir <- dir
        cat("Found manually downloaded shapefile at:", shp_file, "\n")
        
        # Note which version we're using
        if (grepl("nyccwi", dir)) {
          cat("Note: Using council districts WITH water areas\n")
        } else {
          cat("Note: Using council districts WITHOUT water areas (preferred for tree analysis)\n")
        }
        break
      }
    }
  }
  
  if (is.null(shp_file)) {
    cat("No council district shapefile found in expected locations.\n")
    cat("Current working directory:", getwd(), "\n")
    cat("Please either:\n")
    cat("1. Copy the nycc_25c folder to your R working directory, OR\n")
    cat("2. Set your R working directory to: C:/Users/kdsha/OneDrive/Documents/STA9750-2025-FALL\n")
    cat("   using: setwd('C:/Users/kdsha/OneDrive/Documents/STA9750-2025-FALL')\n")
    return(NULL)
  }
  
  # Read the shp file using sf::st_read
  cat("Reading shapefile:", basename(shp_file), "\n")
  
  council_districts <- tryCatch({
    sf::st_read(shp_file, quiet = TRUE)
  }, error = function(e) {
    cat("Failed to read shapefile:", e$message, "\n")
    return(NULL)
  })
  
  if (is.null(council_districts)) return(NULL)
  
  # Transform to WGS84 using st_transform as required
  cat("Transforming to WGS84 coordinate system...\n")
  council_districts_wgs84 <- sf::st_transform(council_districts, crs = "WGS84")
  
  # Simplify geometry for better performance
  cat("Simplifying geometry for better performance...\n")
  council_districts_simplified <- council_districts_wgs84 %>%
    mutate(geometry = st_simplify(geometry, dTolerance = 10))
  
  # Standardize column names if needed
  if (!"CounDist" %in% names(council_districts_simplified)) {
    # Look for district identifier column
    dist_cols <- names(council_districts_simplified)[grepl("dist|council|coun", names(council_districts_simplified), ignore.case = TRUE)]
    if (length(dist_cols) > 0) {
      names(council_districts_simplified)[names(council_districts_simplified) == dist_cols[1]] <- "CounDist"
      cat("Renamed", dist_cols[1], "to CounDist\n")
    }
  }
  
  # Return the transformed data
  cat("Successfully loaded", nrow(council_districts_simplified), "council districts\n")
  return(council_districts_simplified)
}
```

## NYC TREE POINTS
### Task 2: Download NYC Tree Points
```{r}
get_nyc_trees <- function(max_records = 20000) {
  # Create directory
  data_dir <- file.path("data", "mp03")
  if (!dir.exists(data_dir)) {
    dir.create(data_dir, recursive = TRUE, showWarnings = FALSE)
  }
  
  # Check for cached RDS file first for better performance
  cache_file <- file.path(data_dir, paste0("trees_cached_", max_records, ".rds"))
  if (file.exists(cache_file)) {
    cat("Loading cached tree data from:", cache_file, "\n")
    cached_trees <- readRDS(cache_file)
    cat("Loaded", nrow(cached_trees), "cached tree records\n")
    return(cached_trees)
  }
  
  # Base API URL - using GeoJSON format as specified
  base_url <- "https://data.cityofnewyork.us/resource/uvpi-gqnh.geojson"
  
  # Parameters for responsible downloading
  limit <- 10000  # Download in chunks of 10,000
  offset <- 0
  all_data <- list()
  file_counter <- 1
  total_downloaded <- 0
  
  repeat {
    # Stop if we've reached the maximum records limit
    if (total_downloaded >= max_records) {
      cat("Reached maximum record limit of", max_records, "\n")
      break
    }
    
    # Create filename for this chunk
    chunk_file <- file.path(data_dir, paste0("trees_chunk_", sprintf("%03d", file_counter), ".geojson"))
    
    # Only download if file doesn't exist
    if (!file.exists(chunk_file)) {
      cat("Downloading chunk", file_counter, "(offset:", offset, ")...\n")
      
      # Construct URL with limit and offset parameters
      url <- paste0(base_url, "?$limit=", limit, "&$offset=", offset)
      
      # Use httr2 to download data
      response <- tryCatch({
        httr2::request(url) %>%
          httr2::req_headers(
            "Accept" = "application/json",
            "User-Agent" = "R httr2 client"
          ) %>%
          httr2::req_timeout(180) %>%
          httr2::req_perform()
      }, error = function(e) {
        cat("API request failed:", e$message, "\n")
        return(NULL)
      })
      
      if (is.null(response) || httr2::resp_status(response) != 200) {
        cat("Failed to download chunk", file_counter, "\n")
        break
      }
      
      # Save the response to file
      geojson_content <- httr2::resp_body_string(response)
      writeLines(geojson_content, chunk_file)
      cat("Saved chunk to:", chunk_file, "\n")
      
      # Parse to check if we got fewer results than requested (end of data)
      temp_data <- jsonlite::fromJSON(geojson_content)
      
      if (length(temp_data$features) < limit) {
        cat("Downloaded final chunk with", length(temp_data$features), "records\n")
        break
      }
      
    } else {
      cat("Chunk", file_counter, "already exists, skipping download\n")
    }
    
    # Move to next chunk
    offset <- offset + limit
    file_counter <- file_counter + 1
    total_downloaded <- total_downloaded + limit
    
    # Safety break to avoid infinite loops
    if (file_counter > 10) {  # Limit to reasonable number of chunks
      cat("Reached chunk limit, stopping download\n")
      break
    }
  }
  
  # Read in all GeoJSON data files using sf::st_read
  cat("Reading and combining data files...\n")
  geojson_files <- list.files(data_dir, pattern = "trees_chunk_.*\\.geojson$", full.names = TRUE)
  
  if (length(geojson_files) == 0) {
    cat("No tree data files found\n")
    return(NULL)
  }
  
  all_trees <- list()
  for (file in geojson_files) {
    chunk_data <- tryCatch({
      sf::st_read(file, quiet = TRUE)
    }, error = function(e) {
      cat("Failed to read", basename(file), ":", e$message, "\n")
      return(NULL)
    })
    
    if (!is.null(chunk_data) && nrow(chunk_data) > 0) {
      all_trees[[length(all_trees) + 1]] <- chunk_data
    }
  }
  
  if (length(all_trees) == 0) {
    cat("No valid tree data found\n")
    return(NULL)
  }
  
  # Combine all data sets using bind_rows
  combined_trees <- dplyr::bind_rows(all_trees)
  
  # Limit to max_records if specified
  if (nrow(combined_trees) > max_records) {
    combined_trees <- combined_trees %>% slice_head(n = max_records)
    cat("Limited dataset to", max_records, "records for performance\n")
  }
  
  # Cache the result for future use
  saveRDS(combined_trees, cache_file)
  cat("Cached", nrow(combined_trees), "tree records for future use\n")
  
  cat("Successfully processed", nrow(combined_trees), "tree records\n")
  return(combined_trees)
}

# Helper function for distance calculations
new_st_point <- function(lat, lon, ...){
  st_sfc(point = st_point(c(lon, lat))) %>%  # Note: lon, lat order for st_point
    st_set_crs("WGS84")
}
```

### Load Datasets
```{r}
# Load NYC Council Districts
cat("=== Loading NYC Council Districts ===\n")
```


```{r}
# Load NYC City Council Districts (fixed path)
library(sf)
library(dplyr)

# Define shapefile path
shp_path <- "data/mp03/nycc_25c/nycc.shp"

# Check if file exists before reading
if (file.exists(shp_path)) {
  cat("‚úÖ Found shapefile. Reading NYC Council Districts...\n")
  nyc_districts <- st_read(shp_path, quiet = TRUE) %>%
    st_transform("WGS84")
  
  cat("‚úÖ Successfully loaded", nrow(nyc_districts), "council districts\n")
} else {
  stop("‚ùå Shapefile not found at path: ", shp_path)
}
```

```{r}
# Load NYC Tree data (limited for performance)
cat("\n=== Loading NYC Tree Data ===\n")

nyc_trees <- get_nyc_trees(max_records = 15000)  # Limit for better performance

# Display basic information
if (!is.null(nyc_districts) && !is.null(nyc_trees)) {
  cat("\n=== Dataset Summary ===\n")
  cat("Council Districts:", nrow(nyc_districts), "districts\n")
  cat("Tree Records:", nrow(nyc_trees), "trees\n")
  cat("District columns:", paste(names(nyc_districts), collapse = ", "), "\n")
  cat("Tree columns:", paste(names(nyc_trees), collapse = ", "), "\n")
}
```

# Data Integration and Initial Exploration
## Mapping NYC Trees
### Task 3: Plot All Tree Points
```{r}
# Task 3: Plot All Tree Points
cat("\n=== Task 3: Mapping All NYC Trees ===\n")

library(ggplot2)
library(sf)
library(dplyr)

# Sample 3,000 trees for visualization
set.seed(9750)
nyc_trees_sample <- nyc_trees %>% sample_n(3000)

# Create map
ggplot() +
  # Council District Boundaries
  geom_sf(
    data = nyc_districts,
    fill = "#1a1a1a",          # deep charcoal fill
    color = "gray85",          # light boundary lines for contrast
    size = 0.25
  ) +
  # Tree Points
  geom_sf(
    data = nyc_trees_sample,
    color = "#00FF7F",         # neon spring green for strong pop
    alpha = 0.6,
    size = 0.7
  ) +
  # Titles and labels
  labs(
    title = "Using 3,000 Sampled Trees for Visualization",
    subtitle = "Distribution of Street Trees Across NYC Council Districts",
    caption = "Source: NYC Open Data ‚Äî Street Tree Census & City Council District Boundaries"
  ) +
  # Theme adjustments
  theme_void(base_family = "Helvetica") +
  theme(
    plot.background = element_rect(fill = "#000000", color = NA),
    panel.background = element_rect(fill = "#000000", color = NA),
    plot.title = element_text(
      size = 14, face = "bold", color = "white",
      margin = margin(b = 5)
    ),
    plot.subtitle = element_text(
      size = 10, color = "gray80",
      margin = margin(b = 10)
    ),
    plot.caption = element_text(
      size = 8, color = "gray60",
      margin = margin(t = 10)
    ),
    plot.margin = margin(10, 10, 10, 10)
  )
```

## District-Level Analyses of Trees
```{r}
if (!is.null(nyc_districts) && !is.null(nyc_trees)) {
  # Join tree points and district boundaries using spatial join
  cat("üîπ Starting spatial join of NYC trees to council districts...\n")
  
  # Check and display CRS information
  cat("District CRS is set to:", st_crs(nyc_districts)$input, "\n")
  cat("Trees CRS is set to:", st_crs(nyc_trees)$input, "\n")
  
  # Ensure both datasets use the same CRS (WGS84)
  if (st_crs(nyc_districts) != st_crs(nyc_trees)) {
    cat("‚ö†Ô∏è CRS mismatch detected. Transforming tree data to match district CRS...\n")
    nyc_trees <- st_transform(nyc_trees, crs = st_crs(nyc_districts))
  }
  
  # Check for valid geometries
  cat("üîç Validating geometries...\n")
  cat("Number of valid district geometries:", sum(st_is_valid(nyc_districts)), "of", nrow(nyc_districts), "\n")
  cat("Number of valid tree geometries:", sum(st_is_valid(nyc_trees)), "of", nrow(nyc_trees), "\n")
  
  # Check coordinate ranges
  district_bbox <- st_bbox(nyc_districts)
  tree_bbox <- st_bbox(nyc_trees)
  
  cat("District bounding coordinates: longitude", round(district_bbox[1], 3), "to", round(district_bbox[3], 3),
      ", latitude", round(district_bbox[2], 3), "to", round(district_bbox[4], 3), "\n")
  cat("Tree bounding coordinates: longitude", round(tree_bbox[1], 3), "to", round(tree_bbox[3], 3),
      ", latitude", round(tree_bbox[2], 3), "to", round(tree_bbox[4], 3), "\n")
  
  # Use st_intersects: Does a point fall in a region?
  trees_with_districts <- st_join(nyc_trees, nyc_districts, join = st_intersects)
  
  # Check the join results
  trees_with_valid_districts <- trees_with_districts %>%
    filter(!is.na(CounDist))
  
  cat("‚úÖ Number of trees successfully linked to districts:", nrow(trees_with_valid_districts), "of", nrow(trees_with_districts), "\n")
  
  if (nrow(trees_with_valid_districts) == 0) {
    cat("‚ùå No trees were matched to any district polygons.\n")
    cat("This may indicate a CRS mismatch or formatting issue in the tree data.\n")
    cat("Available columns in tree dataset:", paste(names(nyc_trees), collapse = ", "), "\n")
    
    # Use 'cncldist' as backup if available
    if ("cncldist" %in% names(nyc_trees)) {
      cat("‚ÑπÔ∏è 'cncldist' column found. Using it as a backup for district assignment...\n")
      trees_with_districts <- nyc_trees %>%
        mutate(CounDist = as.numeric(cncldist)) %>%
        filter(!is.na(CounDist) & CounDist >= 1 & CounDist <= 51)
      cat("‚úÖ Trees assigned using 'cncldist':", nrow(trees_with_districts), "\n")
    } else {
      cat("‚ö†Ô∏è No backup column available for district assignment. Exiting.\n")
      return(NULL)
    }
  } else {
    trees_with_districts <- trees_with_valid_districts
  }
} else {
  cat("‚ùå Datasets not available. Cannot perform spatial join.\n")
}
```

### Task 4: District-Level Analysis of Tree Coverage

### 1. Which council district has the most trees?
```{r}
if (exists("trees_with_districts")) {
  library(glue)
  
  # Summarize tree counts by district
  tree_counts <- trees_with_districts %>%
    st_drop_geometry() %>%
    group_by(CounDist) %>%
    summarise(tree_count = n(), .groups = 'drop') %>%
    arrange(desc(tree_count))
  
  # Identify district with the most trees
  most_trees_district <- tree_counts$CounDist[1]
  most_trees_count <- tree_counts$tree_count[1]
  
  cat(glue("üå≥ District with the highest number of trees: District {most_trees_district} with {format(most_trees_count, big.mark = ',')} trees\n"))
  
  # Display top 10 districts by tree count
  cat("\nüìä Top 10 districts by tree count:\n")
  tree_counts %>%
    slice_head(n = 10) %>%
    print()
}
```

### 2. Which council district has the highest density of trees? The Shape_Area column from the district shape file will be helpful here.
```{r}
if (exists("trees_with_districts")) {
  library(glue)
  
  # Compute tree counts and density per district
  district_stats <- trees_with_districts %>%
    st_drop_geometry() %>%
    group_by(CounDist) %>%
    summarise(tree_count = n(), .groups = 'drop') %>%
    left_join(
      nyc_districts %>%
        st_drop_geometry() %>%
        select(CounDist, Shape_Area),
      by = "CounDist"
    ) %>%
    mutate(
      area_sq_km = as.numeric(Shape_Area) / 1e6,   # convert area to km¬≤
      tree_density = tree_count / area_sq_km
    ) %>%
    arrange(desc(tree_density))
  
  # Identify the district with the highest density
  highest_density_district <- district_stats$CounDist[1]
  highest_density <- round(district_stats$tree_density[1], 1)
  
  cat(glue("üìè District with the highest tree density: District {highest_density_district} with {highest_density} trees per sq km\n"))
  
  # Display top 10 districts by tree density
  cat("\nüå≥ Top 10 districts by tree density:\n")
  district_stats %>%
    slice_head(n = 10) %>%
    print()
}
```

### 3. Which district has highest fraction of dead trees out of all trees?
```{r}
if (exists("trees_with_districts")) {
  library(glue)
  
  # Compute fraction of dead trees per district
  dead_tree_stats <- trees_with_districts %>%
    st_drop_geometry() %>%
    filter(!is.na(health)) %>%
    group_by(CounDist) %>%
    summarise(
      total_trees = n(),
      dead_trees = sum(health == "Dead", na.rm = TRUE),
      fraction_dead = dead_trees / total_trees,
      .groups = "drop"
    ) %>%
    filter(total_trees >= 5) %>%  # Ensure sufficient sample size
    arrange(desc(fraction_dead))
  
  # Identify district with highest fraction of dead trees
  highest_dead_district <- dead_tree_stats$CounDist[1]
  highest_dead_fraction <- round(dead_tree_stats$fraction_dead[1] * 100, 1)
  
  cat(glue("‚ò†Ô∏è District with the highest fraction of dead trees: District {highest_dead_district} with {highest_dead_fraction}% dead trees\n"))
  
  # Display top 10 districts by dead tree fraction
  cat("\nüå≥ Top 10 districts by fraction of dead trees:\n")
  dead_tree_stats %>%
    slice_head(n = 10) %>%
    print()
}
```

### 4. What is the most common tree species in Manhattan?
```{r}
if (exists("trees_with_districts")) {
  library(glue)
  
  # Assign borough based on council district numbers
  trees_with_borough <- trees_with_districts %>%
    st_drop_geometry() %>%
    mutate(
      borough = case_when(
        CounDist >= 1 & CounDist <= 10  ~ "Manhattan",
        CounDist >= 11 & CounDist <= 18 ~ "Bronx",
        CounDist >= 19 & CounDist <= 32 ~ "Queens",
        CounDist >= 33 & CounDist <= 48 ~ "Brooklyn",
        CounDist >= 49 & CounDist <= 51 ~ "Staten Island",
        TRUE ~ "Other"
      )
    )
  
  # Compute most common species in Manhattan
  manhattan_species <- trees_with_borough %>%
    filter(borough == "Manhattan", !is.na(spc_common)) %>%
    group_by(spc_common) %>%
    summarise(count = n(), .groups = "drop") %>%
    arrange(desc(count))
  
  if (nrow(manhattan_species) > 0) {
    most_common_species <- manhattan_species$spc_common[1]
    species_count <- manhattan_species$count[1]
    
    cat(glue("üå≥ Most common tree species in Manhattan: {most_common_species} with {format(species_count, big.mark = ',')} trees\n"))
    
    # Show top 10 species
    cat("\nüìä Top 10 tree species in Manhattan:\n")
    manhattan_species %>%
      slice_head(n = 10) %>%
      print()
  } else {
    cat("‚ö†Ô∏è No trees found in Manhattan districts (1-10) in the current dataset\n")
  }
}
```

### 5. What is the species of the tree closest to Baruch‚Äôs campus?
```{r}
if (exists("trees_with_districts")) {
  library(glue)
  
  # Baruch College coordinates
  baruch_lat <- 40.7400
  baruch_lon <- -73.9837
  baruch_point <- new_st_point(baruch_lat, baruch_lon)
  
  # Compute distances from Baruch to all trees (matrix method)
  distances <- st_distance(trees_with_districts$geometry, baruch_point)
  
  # Convert to numeric vector (meters)
  trees_with_districts <- trees_with_districts %>%
    mutate(distance_to_baruch = as.numeric(distances)) %>%
    arrange(distance_to_baruch)
  
  # Closest tree
  if (nrow(trees_with_districts) > 0) {
    closest_tree <- trees_with_districts[1, ]
    closest_species <- closest_tree$spc_common
    closest_distance <- round(closest_tree$distance_to_baruch, 1)
    
    cat(glue("üéØ Tree species closest to Baruch College: {closest_species}, approximately {closest_distance} meters away\n"))
    
    # Show top 5 closest trees
    cat("\nüìå Top 5 closest trees to Baruch College:\n")
    trees_with_districts %>%
      st_drop_geometry() %>%
      select(tree_id, spc_common, distance_to_baruch, health, CounDist, boroname, address) %>%
      slice_head(n = 5) %>%
      print()
    
  } else {
    cat("‚ö†Ô∏è No trees found in the dataset for distance calculation.\n")
  }
}
```

# Government Project Design
### Task 5: NYC Parks Proposal
```{r}
library(sf)
library(dplyr)
library(glue)

# --- 1. District Selection and Analysis ---
if (exists("trees_with_districts") && exists("nyc_districts")) {

  selected_district <- 6

  district_trees <- trees_with_districts %>%
    filter(CounDist == selected_district)

  if (nrow(district_trees) > 0) {
    district_analysis <- district_trees %>%
      st_drop_geometry() %>%
      summarise(
        total_trees = n(),
        dead_trees = sum(health == "Dead", na.rm = TRUE),
        poor_trees = sum(health == "Poor", na.rm = TRUE),
        fair_trees = sum(health == "Fair", na.rm = TRUE),
        good_trees = sum(health == "Good", na.rm = TRUE),
        excellent_trees = sum(health == "Excellent", na.rm = TRUE),
        species_count = n_distinct(spc_common, na.rm = TRUE),
        stumps = sum(status == "Stump", na.rm = TRUE),
        .groups = "drop"
      )

    # Create a single string with line breaks
    output_text <- glue(
      "üå≥ Analysis for District {selected_district}:\n",
      "‚Ä¢ Total trees: {format(district_analysis$total_trees, big.mark = ',')}\n",
      "‚Ä¢ Dead trees: {district_analysis$dead_trees}\n",
      "‚Ä¢ Poor condition trees: {district_analysis$poor_trees}\n",
      "‚Ä¢ Fair condition trees: {district_analysis$fair_trees}\n",
      "‚Ä¢ Good condition trees: {district_analysis$good_trees}\n",
      "‚Ä¢ Excellent condition trees: {district_analysis$excellent_trees}\n",
      "‚Ä¢ Tree species diversity: {district_analysis$species_count} species\n",
      "‚Ä¢ Stumps needing replacement: {district_analysis$stumps}\n"
    )

    # Print everything at once
    cat(output_text)

  } else {
    cat(glue("‚ö†Ô∏è No trees found in District {selected_district}.\n"))
  }

} else {
  cat("‚ùå Required datasets are missing. Cannot perform district analysis.\n")
}

```

### Quantitative Comparison Across Districts
```{r}
### Quantitative Comparison Across Districts
if (exists("trees_with_districts") && exists("district_stats")) {

  # Select your district plus at least 3 others for comparison
  comparison_districts <- c(selected_district, 3, 8, 12)
  
  # Summarize key statistics for each district
  district_comparison <- trees_with_districts %>%
    st_drop_geometry() %>%
    filter(CounDist %in% comparison_districts) %>%
    group_by(CounDist) %>%
    summarise(
      total_trees = n(),
      dead_trees = sum(health == "Dead", na.rm = TRUE),
      poor_trees = sum(health == "Poor", na.rm = TRUE),
      fair_trees = sum(health == "Fair", na.rm = TRUE),
      good_trees = sum(health == "Good", na.rm = TRUE),
      excellent_trees = sum(health == "Excellent", na.rm = TRUE),
      dead_poor_pct = ifelse(total_trees > 0,
                             round((dead_trees + poor_trees) / total_trees * 100, 1),
                             0),
      species_diversity = n_distinct(spc_common, na.rm = TRUE),
      stumps = sum(status == "Stump", na.rm = TRUE),
      .groups = 'drop'
    ) %>%
    # Add tree density from precomputed district stats
    left_join(district_stats %>% select(CounDist, tree_density), by = "CounDist") %>%
    # Label districts for easier interpretation
    mutate(district_label = paste("District", CounDist)) %>%
    arrange(desc(dead_poor_pct))  # Sort by highest priority for intervention

  cat("\nüìä Comparison of tree conditions across selected districts:\n")
  print(district_comparison %>% select(district_label, total_trees, dead_trees, poor_trees,
                                       dead_poor_pct, species_diversity, stumps, tree_density))
}
```

## NYC Parks Department Tree Enhancement Proposal
### Project Name: Healthy Streets Initiative ‚Äì Council District 6

### Project Description
The Healthy Streets Initiative is a plan to improve tree health and urban canopy coverage in Council District 6, encompassing the area around Baruch College. The project focuses on **replacing dead trees, removing old stumps, and planting new, climate-resilient trees** to enhance public spaces, provide shade, and improve air quality. The initiative also encourages **community engagement and student involvement**, leveraging the district‚Äôs proximity to Baruch College for educational opportunities.

### Quantitative Scope
Based on our detailed analysis of District 6:

* **Total trees in district:** 694

* **Dead trees identified:** 0

* **Trees in poor/fair condition:** 128

* **Stumps needing replacement:** 11

* **Planned new plantings:** ~50 climate-resilient saplings

This scope is informed by our **spatial analysis**, including counts of tree health, species diversity (28 species), and residual stumps, ensuring the intervention is targeted and achievable.

### Why District 6?
A **quantitative comparison across four districts** (6, 3, 8, 12) demonstrates that District 6 is ideal:

```{r}
library(knitr)
library(dplyr)

# Use district_comparison dataframe for accurate values

district_table <- district_comparison %>%
mutate(
district_label = paste("District", CounDist),
# Highlight District 6
district_label = ifelse(CounDist == selected_district, paste0("**", district_label, "**"), district_label)
) %>%
select(
District = district_label,
`Total Trees` = total_trees,
`Poor/Dead (%)` = dead_poor_pct,
`Species Diversity` = species_diversity,
Stumps = stumps,
`Tree Density (trees/km¬≤)` = tree_density
)

# Render the table

district_table %>%
kable(
caption = "Comparison of Tree Conditions Across Selected Districts",
align = "c",
digits = 1
)
```

Key reasons:

* **Visibility and Impact:** Central Manhattan location, high pedestrian traffic, near Baruch College.

* **Manageable Project Size:** 694 trees allows a focused, measurable intervention that can serve as a pilot for future districts.

* **Community and Student Engagement:** Proximity to Baruch College enables student research projects and volunteer participation.

* **Health-Focused Intervention:** District 6 has the **highest fraction of trees in poor/fair condition** among the compared districts, highlighting a need for replacement and maintenance.

### Visual Evidence

* **Zoomed-in Map of District 6 Trees:** Spatial visualization shows all trees colored by health, with clear identification of areas needing intervention.

###  Zoomed-in Map of Selected District
```{r}
### Zoomed-in Map of Selected District (No ggspatial required)
library(ggplot2)

if (exists("trees_with_districts") && exists("nyc_districts")) {

  district_trees <- trees_with_districts %>% filter(CounDist == selected_district)
  district_boundary <- nyc_districts %>% filter(CounDist == selected_district)
  
  if(nrow(district_trees) > 0 && nrow(district_boundary) > 0) {

    ggplot() +
      # District boundary
      geom_sf(data = district_boundary,
              fill = "#c6dbef",  # light blue
              color = "#08519c",  # dark blue
              size = 1,
              alpha = 0.4) +
      
      # Trees colored by health
      geom_sf(data = district_trees,
              aes(color = health),
              size = 2,
              alpha = 0.8) +
      
      # Color palette
      scale_color_manual(
        values = c(
          "Dead" = "#d73027",       # red
          "Poor" = "#fc8d59",       # orange
          "Fair" = "#fee08b",       # yellow
          "Good" = "#91cf60",       # light green
          "Excellent" = "#1a9850"   # dark green
        ),
        na.value = "gray70"
      ) +
      
      # Zoom to district
      coord_sf(xlim = st_bbox(district_boundary)[c("xmin", "xmax")],
               ylim = st_bbox(district_boundary)[c("ymin", "ymax")]) +
      
      # Labels
      labs(
        title = glue::glue("Tree Health in District {selected_district}"),
        subtitle = glue::glue("Distribution of {nrow(district_trees)} street trees"),
        color = "Tree Health",
        caption = "Data: NYC Department of Parks & Recreation"
      ) +
      
      theme_minimal() +
      theme(
        plot.title = element_text(size = 16, face = "bold"),
        plot.subtitle = element_text(size = 12),
        legend.position = "bottom",
        legend.title = element_text(face = "bold")
      )
  } else {
    cat(glue::glue("‚ö†Ô∏è No trees or district boundary found for District {selected_district}.\n"))
  }
}
```

* **Non-Map Graphic:** Bar chart comparing the **percentage of poor/dead trees across selected districts**, highlighting District 6 as the priority.

### Supporting Visualization
```{r}
library(ggrepel)

if (exists("district_comparison")) {
  
  comparison_chart_data <- district_comparison %>%
    mutate(
      district_label = paste("District", CounDist),
      is_selected = CounDist == selected_district
    )
  
  ggplot(comparison_chart_data, 
         aes(x = reorder(district_label, dead_poor_pct), 
             y = dead_poor_pct, 
             fill = dead_poor_pct)) +
    geom_col(width = 0.7, 
             color = ifelse(comparison_chart_data$is_selected, "black", "gray30"), 
             linewidth = 1) +
    geom_text_repel(
      aes(label = paste0(dead_poor_pct, "%")),
      nudge_y = 3,           # pushes text above the bar
      size = 3,              # slightly smaller text
      fontface = "bold",
      segment.color = NA      # no connecting line
    ) +
    scale_fill_gradient(low = "lightyellow", high = "tomato", name = "% Poor/Dead") +
    labs(
      title = "District Tree Health Comparison",
      subtitle = glue("Highlighting District {selected_district} for Tree Replacement Program"),
      x = "Council District",
      y = "Percentage of Trees in Poor or Dead Condition",
      caption = "Data: NYC Tree Census"
    ) +
    theme_minimal(base_size = 12) +
    theme(
      plot.title = element_text(size = 16, face = "bold"),
      plot.subtitle = element_text(size = 13),
      axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
      axis.title = element_text(face = "bold"),
      legend.position = "right"
    )
}
```

### Expected Outcomes
* Replace all poor/fair trees and remove residual stumps.

* Plant ~50 new climate-resilient trees to increase canopy coverage by ~15%.

* Improve air quality, shade, and urban aesthetics.

* Serve as a pilot program for other districts across Manhattan and NYC.

### Conclusion
This proposal demonstrates how **data-driven insights** from tree inventories and spatial analysis can guide targeted urban forestry projects. The Healthy Streets Initiative in District 6 not only addresses immediate tree health concerns but also engages the community and serves as a scalable model for the city.


## Extra Credit Opportunity #01: Improved Tree Map Visualizations

```{r}
library(leaflet)
library(dplyr)
library(sf)

if (exists("trees_with_districts") && exists("nyc_districts")) {

# Filter for District 6 (or your selected district)

district_trees <- trees_with_districts %>% filter(CounDist == selected_district)
district_boundary <- nyc_districts %>% filter(CounDist == selected_district)

if(nrow(district_trees) > 0 && nrow(district_boundary) > 0) {


# Convert SF to WGS84 for leaflet
district_boundary <- st_transform(district_boundary, 4326)

# Keep only POINT or GEOMETRYCOLLECTION with points

district_trees <- district_trees %>%
  st_transform(4326) %>%
  filter(st_geometry_type(.) %in% c("POINT", "MULTIPOINT", "GEOMETRYCOLLECTION")) %>%
  st_collection_extract("POINT")

# Interactive map
leaflet() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  addPolygons(
    data = district_boundary,
    color = "navy",
    weight = 2,
    fillColor = "lightblue",
    fillOpacity = 0.3,
    label = ~paste("District", selected_district)
  ) %>%
  addCircleMarkers(
    data = district_trees,
    radius = 4,
    color = ~case_when(
      health == "Dead" ~ "red",
      health == "Poor" ~ "orange",
      health == "Fair" ~ "yellow",
      health == "Good" ~ "lightgreen",
      health == "Excellent" ~ "darkgreen",
      TRUE ~ "gray"
    ),
    stroke = FALSE,
    fillOpacity = 0.8,
    popup = ~paste0(
      "<b>Species:</b> ", spc_common, "<br>",
      "<b>Health:</b> ", health, "<br>",
      "<b>Status:</b> ", status
    )
  ) %>%
  addLegend(
    colors = c("red", "orange", "yellow", "lightgreen", "darkgreen"),
    labels = c("Dead", "Poor", "Fair", "Good", "Excellent"),
    title = "Tree Health",
    opacity = 1
  )

}
}
```